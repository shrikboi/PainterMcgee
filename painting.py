import numpy as np
from utils import draw_rectangle, PICTURE_SIZE
import cv2
import colour
from skimage.metrics import structural_similarity as ssim
from enum import Enum


class LOSS(Enum):
    """
    Enum representing different types of loss functions that can be used to evaluate the similarity
    between the target image and the generated painting.
    """
    DELTA = 1
    EUCLIDEAN = 2
    SSIM = 3
    DELTASSIM = 4
    MSESSIM = 5


class Painting(object):
    """
    The Painting class represents an image generated by drawing a series of rectangles.
    It also provides methods to calculate various types of losses to measure how similar
    the generated painting is to a target image.
    """
    def __init__(self, rectangle_list, target_img, weights_matrix, loss_type,
                 ssim_weight=0.5):
        self.rectangle_list = rectangle_list
        self.weights_matrix = weights_matrix
        self.target_image = target_img
        self.image = self.draw_rectangles()
        self.feature_extract = True if loss_type in [LOSS.DELTA, LOSS.EUCLIDEAN] else False
        if loss_type == LOSS.DELTA:
            self.loss = self.delta_e_loss()
        elif loss_type == LOSS.EUCLIDEAN:
            self.loss = self.euclidean_loss()
        elif loss_type == LOSS.SSIM:
            self.loss = self.ssim_loss()
        elif loss_type == LOSS.DELTASSIM:
            self.loss = self.delta_e_loss()*(1-ssim_weight) + self.ssim_loss()*ssim_weight
        elif loss_type == LOSS.MSESSIM:
            self.loss = self.euclidean_loss() * (1 - ssim_weight) + self.ssim_loss() * ssim_weight

    def draw_rectangles(self):
        """
        Draw the rectangles on a blank canvas to create the painting.
        @return: The generated painting as a NumPy array.
        """
        painting = np.ones((*PICTURE_SIZE[::-1], 3), dtype=np.uint8) * 255
        for rectangle in self.rectangle_list:
            draw_rectangle(painting, rectangle)
        return painting

    def delta_e_loss(self):
        """
        Calculate the Delta E color difference loss between the generated painting and the target image.
        @return: The calculated Delta E loss.
        """
        target_image = cv2.cvtColor(self.target_image.astype(np.float32) / 255, cv2.COLOR_RGB2Lab)
        image = cv2.cvtColor(self.image.astype(np.float32) / 255, cv2.COLOR_RGB2Lab)

        delta_e = colour.difference.delta_e.delta_E_CIE2000(target_image, image)
        if self.feature_extract:
            final = np.mean(delta_e * self.weights_matrix)
        else:
            final = np.mean(delta_e)
        return final

    def euclidean_loss(self):
        """
        Calculate the Euclidean distance loss between the generated painting and the target image.
        @return: The calculated Euclidean loss.
        """
        squared_diff = np.square(self.image.astype(np.float32) - self.target_image.astype(np.float32))
        euclidean_distance = np.sqrt(np.sum(squared_diff, axis=-1))
        if self.feature_extract:
            final = np.mean(euclidean_distance * self.weights_matrix)
        else:
            final = np.mean(euclidean_distance)
        return final

    def ssim_loss(self):
        """
        Calculate the SSIM loss between the generated painting and the target image.
        @return: The calculated SSIM loss (negative because higher SSIM indicates better similarity).
        """
        return -ssim(self.image, self.target_image, channel_axis=2, data_range=225)

    def __lt__(self, other):
        """
        Comparison operator for sorting paintings based on their loss values.
        @param other: Another Painting object to compare with.
        @return: True if this painting has a lower loss than the other painting, False otherwise.
        """
        return self.loss < other.loss


class BeamSearch_Node(Painting):
    """
    The BeamSearch_Node class extends the Painting class to represent nodes in a beam search algorithm.
    It includes a reference to the parent node, enabling the reconstruction of the path taken to reach the current node.
    """
    def __init__(self, rectangle_list, target_img, weights_matrix, loss_type, parent=None):
        super().__init__(rectangle_list, target_img, weights_matrix, loss_type)
        self.parent = parent

    def get_path(self):
        """
        Retrieve the path of nodes from the root to the current node.
        @return: A list of BeamSearch_Node objects representing the path.
        """
        path = []
        node = self
        while node is not None:
            path.append(node)
            node = node.parent
        return path[::-1]  # return reversed path